## rust所有权思考2025-10
---
rust的所有权是一个rust独有的特征，或许会有人说rust的所有权很难学，
但是实际上在我看来rust的所有权规则是清晰明了的，
困难的地方在于所有权规则下，与自动GC编程语言相比，
编写代码的思路差异，常规操作的不适用带来的割裂感。
“这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，”

当然话语是苍白的，以一个具体例子举例吧

https://leetcode.com/problems/palindrome-linked-list/
这是leetcode中一个标记为Easy的题目，判断回文列表

思路1：
遍历列表，转数组，从中间往两边推
缺点：额外空间O(n)
优点：思路简洁，编写难度低（对于不关注算法的普通开发者）
、、、
var isPalindrome = function(linkedList) {
    const list = [];

    let travel = linkedList;
    while(travel !== null) {
        list.push(travel.val);
        travel = travel.next;
    }

    const length = list.length;
    let left, right;
    if (length % 2 === 0) {
        left = list[length/2 - 1];
        right = list[length/2 + 1];
    } else {
        left = list[(length + 1)/2];
        right = list[(length + 1)/2];
    }

    while (left >=0 && right <= length -1) {
        if (list[left] != list[right]) {
            return false;
        }
        left = left  -1 ;
        right = right + 1;
    }

    return true;
}
、、、

思路2：
快慢指针找中点 + 反转列表前半段(或者后半段) + 两份半个列表开始比较
说明: 算法题中的标准思路
、、、
var isPalindrome = function(head) {
    let slow = head;
    let fast = head;
    while(fast) {
        if (fast.next) {
            slow = slow.next;
            fast = fast.next.next;
        } else {
            break;
        }
    }

    // 反转
    let prev = null;
    let current = slow;
    while(current) {
        let next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }

    // 比较
    while(prev && head) {
        if (prev.val !== head.val) {
            return false
        }
        prev = prev.next;
        head = head.next;
    }
    return true
}
、、、
之前是用js编写的
我以思路2尝试用rust写一遍

```
    let slow = head;
    let fast = head;
```
一开始我们就遇到了麻烦，直接赋值会导致所有权的转移，head无法转移两次，所以我们需要尝试获取head的引用
```
        let mut slow = head.as_ref();
        let mut fast = head.as_ref();
```

接着尝试以之前的思路，通过快慢指针找到中点
```
        while fast.is_some() && fast.unwrap().next.is_some() {
            slow = slow.unwrap().next.as_ref();
            fast = fast.unwrap().next.as_ref().unwrap().next.as_ref();
        }
```
看起来不错，不过，unwrap会消耗所有权，我们得换一种方式（todo: unwrap消耗所有权的理解，这里真的有问题吗）
```
        while fast.and_then(|n| n.next.as_ref()).is_some() {
            slow = slow.and_then(|n| n.next.as_ref());
            fast = fast
                .and_then(|n| n.next.as_ref())
                .and_then(|n| n.next.as_ref());
        }
```
当然用match匹配也是可以的，就是读起来没有那么清晰。
拿到了中点之后，我们就要反转一半列表，反转前半和后半略有不同，我们选择后半。
我们无法直接从中点开始反转，快慢指针限制了我们一开始就不能使用两个可变引用，同时所有权也只能转移一次，
造就了我们只能使用两个不可变应用。在这个前提下，我们拿到的中点也不能直接就地反转。

从这里开始，就是rust的所有权系统带来的真正让人头疼的地方。
你会发现，我们又需要重新开始，让slow具有所有权或者可修改的权力。

思路1：能否原地拿到slow所有权？不行，slow是不可变引用
思路2：能不能slow是可变引用，fast是不可变引用？不行，rust的所有权规则限制
思路3：拿到slow之后，再次遍历链表，再次遍历中使用可变引用或者所有权转移？不行，slow和fast已经是不可变引用了
思路4：放弃快慢指针，转为获取链表长度，通过数学计算得到中点的思路
```
        let mut head = head;
        // 第一阶段：获取链表长度（只读）
        let mut len = 0;
        {
            let mut curr = head.as_ref();
            while let Some(node) = curr {
                len += 1;
                curr = node.next.as_ref();
            }
        }
        // 第二阶段：移动到中点位置（可变引用）
        let mut curr = &mut head;
        for _ in 0..len / 2 {
            if let Some(node) = curr {
                curr = &mut node.next;
            }
        }

        // 第三阶段：反转后半部分（获取所有权）
        let mut prev = None;
        let mut second_half = curr.take();

        while let Some(mut node) = second_half {
            let next = node.next.take();
            node.next = prev;
            prev = Some(node);
            second_half = next;
        }

        // 第四阶段：比较前后两部分
        let mut first = head.as_ref();
        let mut second = prev.as_ref();

        while let (Some(f), Some(s)) = (first, second) {
            if f.val != s.val {
                return false;
            }
            first = f.next.as_ref();
            second = s.next.as_ref();
        }

        true
```